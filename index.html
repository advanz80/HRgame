<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HR Quest: De Weg naar Driessen</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #gameWrapper {
            width: 100%;
            max-width: 800px;
            height: 100vh;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px;
        }

        #gameCanvas {
            background: linear-gradient(180deg, #87CEEB 0%, #E0F6FF 100%);
            border-radius: 10px;
            display: block;
            flex: 1;
            min-height: 0;
            width: 100%;
        }

        /* HUD */
        #hud {
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 8px 10px;
            color: white;
            font-size: 12px;
            flex-shrink: 0;
        }

        .hud-item {
            background: rgba(0,0,0,0.5);
            padding: 6px 12px;
            border-radius: 15px;
        }

        /* Mobile Controls */
        #mobileControls {
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 10px 15px;
            padding-bottom: max(10px, env(safe-area-inset-bottom));
            gap: 15px;
            flex-shrink: 0;
        }

        .control-group {
            display: flex;
            gap: 8px;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.4);
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            transition: all 0.1s;
        }

        @media (min-width: 500px) {
            .control-btn {
                width: 70px;
                height: 70px;
                font-size: 26px;
            }
        }

        .control-btn:active, .control-btn.active {
            background: rgba(255,255,255,0.5);
            transform: scale(0.92);
        }

        .control-btn.action {
            background: rgba(233, 69, 96, 0.7);
            border-color: #e94560;
        }

        .control-btn.jump {
            background: rgba(78, 204, 163, 0.7);
            border-color: #4ecca3;
        }

        .control-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .control-label {
            font-size: 10px;
            color: rgba(255,255,255,0.7);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Screens */
        .screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            height: 100dvh;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: safe center;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            padding: 20px;
            padding-top: max(20px, env(safe-area-inset-top));
            padding-bottom: max(20px, env(safe-area-inset-bottom));
            text-align: center;
            z-index: 100;
            overflow-y: auto;
        }

        .screen.active {
            display: flex;
        }

        .title {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #e94560, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 1.2em;
            color: #4ecca3;
            margin-bottom: 30px;
        }

        .description {
            max-width: 400px;
            line-height: 1.8;
            opacity: 0.9;
            margin-bottom: 30px;
        }

        .btn {
            padding: 18px 50px;
            font-size: 1.2em;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
            margin: 10px;
        }

        .btn:active {
            transform: scale(0.95);
        }

        .btn-primary {
            background: linear-gradient(90deg, #e94560, #ff6b6b);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(90deg, #4ecca3, #45b7aa);
            color: white;
        }

        .character-preview {
            font-size: 80px;
            margin-bottom: 20px;
            animation: bounce 1s ease-in-out infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }

        /* Level Complete */
        .level-banner {
            background: rgba(78, 204, 163, 0.2);
            border: 2px solid #4ecca3;
            padding: 20px 40px;
            border-radius: 15px;
            margin: 20px 0;
        }

        /* Victory Screen */
        .victory-box {
            background: linear-gradient(135deg, rgba(255,215,0,0.2), rgba(255,170,0,0.1));
            border: 3px solid #ffd700;
            padding: 30px;
            border-radius: 20px;
            max-width: 400px;
            margin: 20px 0;
        }

        .victory-box h3 {
            color: #ffd700;
            font-size: 1.5em;
            margin-bottom: 10px;
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            top: -10px;
            pointer-events: none;
            z-index: 200;
        }

        @keyframes fall {
            to {
                top: 100vh;
                transform: rotate(720deg);
            }
        }

        /* Instructions */
        .controls-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
            text-align: left;
        }

        .control-item {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 10px;
            font-size: 0.9em;
        }

        .control-item span {
            color: #4ecca3;
            font-weight: bold;
        }

        /* Game Over */
        .game-over-stats {
            display: flex;
            gap: 30px;
            margin: 20px 0;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            color: #4ecca3;
            font-weight: bold;
        }

        .stat-label {
            font-size: 0.8em;
            opacity: 0.7;
        }

        /* Level indicator */
        .level-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 10px 25px;
            border-radius: 20px;
            font-size: 1.1em;
            z-index: 50;
            color: white;
        }

        /* AI Power indicator */
        .ai-power {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .ai-bar {
            width: 80px;
            height: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
            overflow: hidden;
        }

        .ai-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <!-- Start Screen -->
    <div id="startScreen" class="screen active">
        <div class="character-preview">üë©‚Äçüíº</div>
        <h1 class="title">HR Quest</h1>
        <p class="subtitle">De Weg naar Driessen</p>
        <p class="description">
            Spring door de wereld van HR en versla de vervelende taken die je energie opslurpen!
            Gebruik AI-krachten om vijanden te verslaan en bereik je einddoel:
            <strong style="color: #ffd700">Driessen Groep in Helmond!</strong>
        </p>
        <div class="controls-info">
            <div class="control-item"><span>‚óÄ ‚ñ∂</span> Bewegen</div>
            <div class="control-item"><span>‚ñ≤</span> Springen</div>
            <div class="control-item"><span>‚ö°</span> AI Aanval</div>
            <div class="control-item"><span>üíÄ</span> Spring op vijanden</div>
        </div>
        <button class="btn btn-primary" onclick="startGame()">Start Avontuur!</button>
    </div>

    <!-- Level Intro Screen -->
    <div id="levelIntroScreen" class="screen">
        <h2 id="levelIntroTitle" style="font-size: 1.8em; color: #4ecca3; margin-bottom: 10px;">Level 1</h2>
        <h1 id="levelIntroName" class="title">Administratie Archipel</h1>
        <p id="levelIntroDesc" class="description"></p>
        <div class="level-banner">
            <span id="levelIntroEnemies">Vijanden: üìÑ üìä üìß</span>
        </div>
        <button class="btn btn-secondary" onclick="startLevel()">Start Level</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="screen">
        <h1 style="font-size: 2em; color: #e94560; margin-bottom: 20px;">Game Over</h1>
        <p class="description">De taken hebben je overweldigd... Maar geef niet op!</p>
        <div class="game-over-stats">
            <div class="stat">
                <div class="stat-value" id="goScore">0</div>
                <div class="stat-label">Score</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="goDefeated">0</div>
                <div class="stat-label">Verslagen</div>
            </div>
        </div>
        <button class="btn btn-primary" onclick="restartGame()">Opnieuw Proberen</button>
    </div>

    <!-- Victory Screen -->
    <div id="victoryScreen" class="screen">
        <h1 class="title">üèÜ GEFELICITEERD! üèÜ</h1>
        <p class="subtitle">Je hebt het gehaald!</p>
        <div class="victory-box">
            <h3>üè¢ Driessen Groep</h3>
            <p style="color: #aaa; margin-bottom: 15px;">üìç Helmond</p>
            <p style="line-height: 1.7;">
                Welkom bij Driessen Groep - d√© plek waar HR-professionals samenkomen
                voor <strong style="color: #4ecca3">inspiratie</strong> en
                <strong style="color: #4ecca3">verbinding</strong>!
            </p>
        </div>
        <div class="game-over-stats">
            <div class="stat">
                <div class="stat-value" id="victoryScore">0</div>
                <div class="stat-label">Totale Score</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="victoryDefeated">0</div>
                <div class="stat-label">Taken Verslagen</div>
            </div>
        </div>
        <button class="btn btn-primary" onclick="restartGame()">Opnieuw Spelen</button>
    </div>

    <!-- Game Container -->
    <div id="gameWrapper" style="display: none;">
        <div id="hud">
            <div class="hud-item">‚ù§Ô∏è <span id="healthDisplay">3</span></div>
            <div class="hud-item">‚≠ê <span id="scoreDisplay">0</span></div>
            <div class="hud-item ai-power">‚ö° <div class="ai-bar"><div class="ai-fill" id="aiPowerBar" style="width: 100%"></div></div></div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="mobileControls">
            <div class="control-group">
                <div class="control-wrapper">
                    <button class="control-btn" id="btnLeft">‚óÄ</button>
                    <span class="control-label">Links</span>
                </div>
                <div class="control-wrapper">
                    <button class="control-btn" id="btnRight">‚ñ∂</button>
                    <span class="control-label">Rechts</span>
                </div>
            </div>
            <div class="control-group">
                <div class="control-wrapper">
                    <button class="control-btn action" id="btnAttack">‚ö°</button>
                    <span class="control-label">AI Aanval</span>
                </div>
                <div class="control-wrapper">
                    <button class="control-btn jump" id="btnJump">‚ñ≤</button>
                    <span class="control-label">Spring</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== GAME CONFIG ====================
        const CONFIG = {
            gravity: 0.6,
            friction: 0.8,
            playerSpeed: 5,
            jumpForce: 14,
            aiAttackCost: 25,
            aiRechargeRate: 0.3
        };

        // ==================== LEVEL DATA ====================
        const LEVELS = [
            {
                name: "Administratie Archipel",
                description: "De papieren monsters wachten op je! Spring over de stapels en versla de administratieve chaos.",
                background: { sky: '#87CEEB', ground: '#8B4513' },
                enemies: ['üìÑ', 'üìä', 'üìß'],
                platforms: [
                    { x: 0, y: 350, w: 300, h: 40 },
                    { x: 350, y: 300, w: 150, h: 40 },
                    { x: 550, y: 240, w: 200, h: 40 },
                    { x: 800, y: 300, w: 150, h: 40 },
                    { x: 1000, y: 350, w: 300, h: 40 },
                    { x: 1350, y: 280, w: 150, h: 40 },
                    { x: 1550, y: 220, w: 200, h: 40 },
                    { x: 1800, y: 280, w: 150, h: 40 },
                    { x: 2000, y: 350, w: 400, h: 40 }
                ],
                enemySpawns: [
                    { x: 400, y: 250, type: 0 },
                    { x: 600, y: 190, type: 1 },
                    { x: 1050, y: 300, type: 0 },
                    { x: 1400, y: 230, type: 2 },
                    { x: 1600, y: 170, type: 1 },
                    { x: 2100, y: 300, type: 0 }
                ],
                goalX: 2300
            },
            {
                name: "Formulieren Fabriek",
                description: "Eindeloze formulieren rollen van de band! Navigeer door de fabriek en automatiseer de chaos.",
                background: { sky: '#4A4A6A', ground: '#555555' },
                enemies: ['üìù', 'üìë', 'üßæ'],
                platforms: [
                    { x: 0, y: 350, w: 250, h: 40 },
                    { x: 300, y: 290, w: 120, h: 40 },
                    { x: 470, y: 230, w: 120, h: 40 },
                    { x: 640, y: 290, w: 180, h: 40 },
                    { x: 870, y: 350, w: 200, h: 40 },
                    { x: 1120, y: 280, w: 150, h: 40 },
                    { x: 1320, y: 210, w: 150, h: 40 },
                    { x: 1520, y: 280, w: 150, h: 40 },
                    { x: 1720, y: 350, w: 200, h: 40 },
                    { x: 1970, y: 290, w: 150, h: 40 },
                    { x: 2170, y: 350, w: 400, h: 40 }
                ],
                enemySpawns: [
                    { x: 350, y: 240, type: 0 },
                    { x: 520, y: 180, type: 1 },
                    { x: 700, y: 240, type: 2 },
                    { x: 950, y: 300, type: 0 },
                    { x: 1170, y: 230, type: 1 },
                    { x: 1370, y: 160, type: 2 },
                    { x: 1770, y: 300, type: 0 },
                    { x: 2020, y: 240, type: 1 }
                ],
                goalX: 2450
            },
            {
                name: "Vergadering Vallei",
                description: "De meeting monsters vergaderen eindeloos! Spring door de agenda en bereik de uitgang.",
                background: { sky: '#2C3E50', ground: '#1A252F' },
                enemies: ['üìÖ', '‚è∞', 'üë•'],
                platforms: [
                    { x: 0, y: 350, w: 200, h: 40 },
                    { x: 250, y: 300, w: 100, h: 40 },
                    { x: 400, y: 250, w: 100, h: 40 },
                    { x: 550, y: 190, w: 100, h: 40 },
                    { x: 700, y: 250, w: 150, h: 40 },
                    { x: 900, y: 310, w: 150, h: 40 },
                    { x: 1100, y: 350, w: 200, h: 40 },
                    { x: 1350, y: 280, w: 120, h: 40 },
                    { x: 1520, y: 210, w: 120, h: 40 },
                    { x: 1690, y: 140, w: 120, h: 40 },
                    { x: 1860, y: 210, w: 120, h: 40 },
                    { x: 2030, y: 280, w: 120, h: 40 },
                    { x: 2200, y: 350, w: 400, h: 40 }
                ],
                enemySpawns: [
                    { x: 280, y: 250, type: 0 },
                    { x: 580, y: 140, type: 1 },
                    { x: 750, y: 200, type: 2 },
                    { x: 950, y: 260, type: 0 },
                    { x: 1150, y: 300, type: 1 },
                    { x: 1400, y: 230, type: 2 },
                    { x: 1720, y: 90, type: 0 },
                    { x: 1890, y: 160, type: 1 },
                    { x: 2080, y: 230, type: 2 }
                ],
                goalX: 2500
            },
            {
                name: "De Weg naar Helmond",
                description: "De laatste etappe! Versla de eindbaas Bureaucratie en bereik Driessen Groep!",
                background: { sky: '#1a1a2e', ground: '#2d2d44' },
                enemies: ['‚è≥', 'üß©', 'üëî'],
                platforms: [
                    { x: 0, y: 350, w: 200, h: 40 },
                    { x: 250, y: 300, w: 100, h: 40 },
                    { x: 400, y: 240, w: 100, h: 40 },
                    { x: 250, y: 180, w: 100, h: 40 },
                    { x: 400, y: 120, w: 100, h: 40 },
                    { x: 550, y: 180, w: 150, h: 40 },
                    { x: 750, y: 240, w: 100, h: 40 },
                    { x: 900, y: 300, w: 150, h: 40 },
                    { x: 1100, y: 350, w: 150, h: 40 },
                    { x: 1300, y: 300, w: 100, h: 40 },
                    { x: 1450, y: 240, w: 100, h: 40 },
                    { x: 1600, y: 180, w: 150, h: 40 },
                    { x: 1800, y: 240, w: 100, h: 40 },
                    { x: 1950, y: 300, w: 150, h: 40 },
                    { x: 2150, y: 350, w: 500, h: 40 }
                ],
                enemySpawns: [
                    { x: 280, y: 250, type: 0 },
                    { x: 430, y: 190, type: 1 },
                    { x: 280, y: 130, type: 0 },
                    { x: 600, y: 130, type: 1 },
                    { x: 780, y: 190, type: 2 },
                    { x: 950, y: 250, type: 0 },
                    { x: 1150, y: 300, type: 1 },
                    { x: 1330, y: 250, type: 2 },
                    { x: 1480, y: 190, type: 0 },
                    { x: 1650, y: 130, type: 1 },
                    { x: 1830, y: 190, type: 2 },
                    { x: 2300, y: 300, type: 2, boss: true }
                ],
                goalX: 2550
            }
        ];

        // ==================== GAME STATE ====================
        let canvas, ctx;
        let gameState = {
            running: false,
            currentLevel: 0,
            score: 0,
            health: 3,
            defeated: 0,
            aiPower: 100
        };

        let player = {
            x: 50,
            y: 250,
            w: 40,
            h: 50,
            vx: 0,
            vy: 0,
            onGround: false,
            facingRight: true
        };

        let camera = { x: 0 };
        let platforms = [];
        let enemies = [];
        let particles = [];
        let aiProjectiles = [];
        let goal = null;

        let keys = {
            left: false,
            right: false,
            jump: false,
            attack: false
        };
        let canAttack = true;

        // ==================== INITIALIZATION ====================
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            setupControls();
        }

        function resizeCanvas() {
            // Get the actual rendered size of the canvas element
            const rect = canvas.getBoundingClientRect();
            // Ensure minimum size and valid dimensions
            canvas.width = Math.max(300, rect.width || 800);
            canvas.height = Math.max(200, rect.height || 400);
        }

        // ==================== CONTROLS ====================
        function setupControls() {
            // Keyboard
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
                if (e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
                if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') {
                    e.preventDefault();
                    keys.jump = true;
                }
                if (e.key === 'e' || e.key === 'f') keys.attack = true;
            });

            document.addEventListener('keyup', (e) => {
                if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
                if (e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
                if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') keys.jump = false;
                if (e.key === 'e' || e.key === 'f') keys.attack = false;
            });

            // Mobile buttons - improved touch handling
            const btnLeft = document.getElementById('btnLeft');
            const btnRight = document.getElementById('btnRight');
            const btnJump = document.getElementById('btnJump');
            const btnAttack = document.getElementById('btnAttack');

            const addTouch = (btn, key) => {
                // Touch events
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    keys[key] = true;
                    btn.classList.add('active');
                }, { passive: false });

                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    keys[key] = false;
                    btn.classList.remove('active');
                }, { passive: false });

                btn.addEventListener('touchcancel', (e) => {
                    keys[key] = false;
                    btn.classList.remove('active');
                }, { passive: false });

                // Mouse events (for desktop testing)
                btn.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    keys[key] = true;
                    btn.classList.add('active');
                });

                btn.addEventListener('mouseup', (e) => {
                    keys[key] = false;
                    btn.classList.remove('active');
                });

                btn.addEventListener('mouseleave', () => {
                    keys[key] = false;
                    btn.classList.remove('active');
                });
            };

            addTouch(btnLeft, 'left');
            addTouch(btnRight, 'right');
            addTouch(btnJump, 'jump');
            addTouch(btnAttack, 'attack');

            // Prevent default touch behavior on the game wrapper
            document.getElementById('gameWrapper').addEventListener('touchmove', (e) => {
                e.preventDefault();
            }, { passive: false });
        }

        // ==================== GAME FLOW ====================
        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            const screen = document.getElementById(id);
            if (screen) screen.classList.add('active');

            document.getElementById('gameWrapper').style.display = id === 'none' ? 'flex' : 'none';
        }

        function startGame() {
            gameState = {
                running: false,
                currentLevel: 0,
                score: 0,
                health: 3,
                defeated: 0,
                aiPower: 100
            };
            showLevelIntro(0);
        }

        function showLevelIntro(levelIndex) {
            const level = LEVELS[levelIndex];
            document.getElementById('levelIntroTitle').textContent = `Level ${levelIndex + 1}`;
            document.getElementById('levelIntroName').textContent = level.name;
            document.getElementById('levelIntroDesc').textContent = level.description;
            document.getElementById('levelIntroEnemies').textContent = `Vijanden: ${level.enemies.join(' ')}`;
            showScreen('levelIntroScreen');
        }

        function startLevel() {
            showScreen('none');
            document.getElementById('gameWrapper').style.display = 'flex';

            // Important: resize canvas AFTER gameWrapper is visible
            // Use requestAnimationFrame to ensure layout is complete
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    resizeCanvas();
                    loadLevel(gameState.currentLevel);
                    gameState.running = true;
                    requestAnimationFrame(gameLoop);
                });
            });
        }

        function loadLevel(levelIndex) {
            const level = LEVELS[levelIndex];

            // Scale factor based on canvas height (designed for 450px)
            const baseHeight = 450;
            const scale = canvas.height / baseHeight;

            player.x = 50;
            player.y = 200 * scale;
            player.vx = 0;
            player.vy = 0;
            player.onGround = false;

            camera.x = 0;

            // Scale platform positions
            platforms = level.platforms.map(p => ({
                ...p,
                y: p.y * scale,
                h: p.h * scale
            }));

            // Scale enemy positions
            enemies = level.enemySpawns.map(e => ({
                x: e.x,
                y: e.y * scale,
                w: e.boss ? 60 : 40,
                h: e.boss ? 70 : 50,
                type: e.type,
                sprite: level.enemies[e.type],
                vx: (Math.random() > 0.5 ? 1 : -1) * (e.boss ? 1.5 : 2),
                hp: e.boss ? 5 : 1,
                boss: e.boss || false,
                startX: e.x,
                range: e.boss ? 150 : 100
            }));

            goal = {
                x: level.goalX,
                y: 270 * scale,
                w: 80,
                h: 80
            };

            particles = [];
            aiProjectiles = [];

            updateHUD();
        }

        function nextLevel() {
            gameState.currentLevel++;
            if (gameState.currentLevel >= LEVELS.length) {
                showVictory();
            } else {
                showLevelIntro(gameState.currentLevel);
            }
        }

        function showVictory() {
            gameState.running = false;
            document.getElementById('victoryScore').textContent = gameState.score;
            document.getElementById('victoryDefeated').textContent = gameState.defeated;
            showScreen('victoryScreen');
            createConfetti();
        }

        function showGameOver() {
            gameState.running = false;
            document.getElementById('goScore').textContent = gameState.score;
            document.getElementById('goDefeated').textContent = gameState.defeated;
            showScreen('gameOverScreen');
        }

        function restartGame() {
            startGame();
        }

        // ==================== GAME LOOP ====================
        function gameLoop() {
            if (!gameState.running) return;

            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        function update() {
            // Recharge AI
            if (gameState.aiPower < 100) {
                gameState.aiPower = Math.min(100, gameState.aiPower + CONFIG.aiRechargeRate);
                document.getElementById('aiPowerBar').style.width = gameState.aiPower + '%';
            }

            // Player movement
            if (keys.left) {
                player.vx = -CONFIG.playerSpeed;
                player.facingRight = false;
            } else if (keys.right) {
                player.vx = CONFIG.playerSpeed;
                player.facingRight = true;
            } else {
                player.vx *= CONFIG.friction;
            }

            // Jump
            if (keys.jump && player.onGround) {
                player.vy = -CONFIG.jumpForce;
                player.onGround = false;
            }

            // AI Attack
            if (keys.attack && canAttack && gameState.aiPower >= CONFIG.aiAttackCost) {
                fireAIProjectile();
                gameState.aiPower -= CONFIG.aiAttackCost;
                document.getElementById('aiPowerBar').style.width = gameState.aiPower + '%';
                canAttack = false;
                setTimeout(() => canAttack = true, 300);
            }

            // Apply gravity
            player.vy += CONFIG.gravity;

            // Move player
            player.x += player.vx;
            player.y += player.vy;

            // Platform collision
            player.onGround = false;
            for (const plat of platforms) {
                if (player.x + player.w > plat.x && player.x < plat.x + plat.w) {
                    // Landing on top
                    if (player.vy > 0 && player.y + player.h > plat.y && player.y + player.h < plat.y + plat.h + player.vy) {
                        player.y = plat.y - player.h;
                        player.vy = 0;
                        player.onGround = true;
                    }
                }
            }

            // Fall off screen
            if (player.y > canvas.height + 100) {
                takeDamage();
            }

            // Update camera
            const targetCamX = player.x - canvas.width / 3;
            camera.x += (targetCamX - camera.x) * 0.1;
            camera.x = Math.max(0, camera.x);

            // Update enemies
            for (const enemy of enemies) {
                enemy.x += enemy.vx;

                // Patrol behavior
                if (Math.abs(enemy.x - enemy.startX) > enemy.range) {
                    enemy.vx *= -1;
                }

                // Check collision with player
                if (checkCollision(player, enemy)) {
                    // Check if player is stomping
                    if (player.vy > 0 && player.y + player.h - 10 < enemy.y + enemy.h / 2) {
                        damageEnemy(enemy);
                        player.vy = -10; // Bounce
                    } else {
                        takeDamage();
                    }
                }
            }

            // Update AI projectiles
            for (let i = aiProjectiles.length - 1; i >= 0; i--) {
                const proj = aiProjectiles[i];
                proj.x += proj.vx;

                // Check collision with enemies
                for (const enemy of enemies) {
                    if (checkCollision(proj, enemy)) {
                        damageEnemy(enemy);
                        aiProjectiles.splice(i, 1);
                        break;
                    }
                }

                // Remove if off screen
                if (proj.x > camera.x + canvas.width + 100 || proj.x < camera.x - 100) {
                    aiProjectiles.splice(i, 1);
                }
            }

            // Remove dead enemies
            enemies = enemies.filter(e => e.hp > 0);

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.life--;
                if (p.life <= 0) particles.splice(i, 1);
            }

            // Check goal
            if (goal && checkCollision(player, goal)) {
                gameState.running = false;
                setTimeout(nextLevel, 500);
            }
        }

        function fireAIProjectile() {
            aiProjectiles.push({
                x: player.x + (player.facingRight ? player.w : 0),
                y: player.y + player.h / 2 - 10,
                w: 30,
                h: 20,
                vx: player.facingRight ? 12 : -12
            });

            // Visual effect
            for (let i = 0; i < 5; i++) {
                particles.push({
                    x: player.x + player.w / 2,
                    y: player.y + player.h / 2,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    color: '#667eea',
                    life: 20
                });
            }
        }

        function damageEnemy(enemy) {
            enemy.hp--;
            gameState.score += 10;

            // Particles
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: enemy.x + enemy.w / 2,
                    y: enemy.y + enemy.h / 2,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8 - 3,
                    color: '#ffd700',
                    life: 30
                });
            }

            if (enemy.hp <= 0) {
                gameState.defeated++;
                gameState.score += enemy.boss ? 100 : 25;
            }

            updateHUD();
        }

        function takeDamage() {
            gameState.health--;
            updateHUD();

            if (gameState.health <= 0) {
                showGameOver();
            } else {
                // Reset player position (scale Y based on canvas height)
                const scale = canvas.height / 450;
                player.x = 50;
                player.y = 200 * scale;
                player.vx = 0;
                player.vy = 0;
                camera.x = 0;
            }
        }

        function checkCollision(a, b) {
            return a.x < b.x + b.w &&
                   a.x + a.w > b.x &&
                   a.y < b.y + b.h &&
                   a.y + a.h > b.y;
        }

        function updateHUD() {
            document.getElementById('healthDisplay').textContent = gameState.health;
            document.getElementById('scoreDisplay').textContent = gameState.score;
        }

        // ==================== RENDERING ====================
        function render() {
            const level = LEVELS[gameState.currentLevel];

            // Clear with sky color
            ctx.fillStyle = level.background.sky;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw background elements
            drawBackground(level);

            ctx.save();
            ctx.translate(-camera.x, 0);

            // Draw platforms
            for (const plat of platforms) {
                ctx.fillStyle = level.background.ground;
                ctx.fillRect(plat.x, plat.y, plat.w, plat.h);

                // Platform top (grass/surface)
                ctx.fillStyle = gameState.currentLevel === 3 ? '#4ecca3' : '#4ecca3';
                ctx.fillRect(plat.x, plat.y, plat.w, 8);
            }

            // Draw goal
            if (goal) {
                ctx.font = '50px Arial';
                ctx.textAlign = 'center';
                if (gameState.currentLevel === LEVELS.length - 1) {
                    ctx.fillText('üè¢', goal.x + goal.w / 2, goal.y + 40);
                    ctx.font = '16px Arial';
                    ctx.fillStyle = '#ffd700';
                    ctx.fillText('Driessen', goal.x + goal.w / 2, goal.y + 60);
                } else {
                    ctx.fillText('üö™', goal.x + goal.w / 2, goal.y + 40);
                }
            }

            // Draw enemies
            for (const enemy of enemies) {
                ctx.font = enemy.boss ? '50px Arial' : '35px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(enemy.sprite, enemy.x + enemy.w / 2, enemy.y + enemy.h - 5);

                // Boss health bar
                if (enemy.boss && enemy.hp > 0) {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(enemy.x - 10, enemy.y - 20, enemy.w + 20, 8);
                    ctx.fillStyle = '#e94560';
                    ctx.fillRect(enemy.x - 10, enemy.y - 20, (enemy.w + 20) * (enemy.hp / 5), 8);
                }
            }

            // Draw AI projectiles
            for (const proj of aiProjectiles) {
                ctx.fillStyle = '#667eea';
                ctx.beginPath();
                ctx.arc(proj.x + proj.w / 2, proj.y + proj.h / 2, 12, 0, Math.PI * 2);
                ctx.fill();

                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('‚ö°', proj.x + proj.w / 2, proj.y + proj.h / 2 + 6);
            }

            // Draw player
            ctx.font = '40px Arial';
            ctx.textAlign = 'center';
            ctx.save();
            if (!player.facingRight) {
                ctx.translate(player.x + player.w, 0);
                ctx.scale(-1, 1);
                ctx.fillText('üë©‚Äçüíº', player.w / 2, player.y + player.h - 5);
            } else {
                ctx.fillText('üë©‚Äçüíº', player.x + player.w / 2, player.y + player.h - 5);
            }
            ctx.restore();

            // Draw particles
            for (const p of particles) {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 30;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            ctx.restore();

            // Draw level name
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(canvas.width / 2 - 100, 10, 200, 30);
            ctx.fillStyle = 'white';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Level ${gameState.currentLevel + 1}: ${level.name}`, canvas.width / 2, 30);
        }

        function drawBackground(level) {
            // Decorative background elements
            ctx.globalAlpha = 0.3;
            ctx.font = '30px Arial';

            const bgEmojis = {
                0: ['üìã', 'üìÅ', 'üóÇÔ∏è'],
                1: ['‚öôÔ∏è', 'üîß', 'üì¶'],
                2: ['üíº', '‚òï', 'ü™ë'],
                3: ['üåü', '‚ú®', 'üè¢']
            };

            const emojis = bgEmojis[gameState.currentLevel] || bgEmojis[0];

            for (let i = 0; i < 10; i++) {
                const x = (i * 200 - camera.x * 0.3) % (canvas.width + 200);
                const y = 100 + Math.sin(i * 0.5) * 50;
                ctx.fillText(emojis[i % emojis.length], x, y);
            }

            ctx.globalAlpha = 1;
        }

        function createConfetti() {
            const colors = ['#e94560', '#4ecca3', '#ffd700', '#667eea', '#ff6b6b'];
            for (let i = 0; i < 100; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + 'vw';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animation = `fall ${2 + Math.random() * 2}s linear forwards`;
                    document.body.appendChild(confetti);
                    setTimeout(() => confetti.remove(), 4000);
                }, i * 30);
            }
        }

        // Start
        init();
    </script>
</body>
</html>
